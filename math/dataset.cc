#include <iostream>
#include <fstream>

#include <iostream>
#include <iterator>
#include <cstdlib>
#include <cassert>
#include <cmath>

#include <gsl/gsl_math.h>
#include <gsl/gsl_combination.h>

#include "dataset.hh"

using std::cout;
using std::cerr;
using std::ofstream;

MSZDataSet::MSZDataSet(double **m, uint nrows, uint ncols, uint outputs) 
  : nrows(nrows), rfeatures(ncols - outputs), ncols(ncols), outputs(outputs),
    stdDone(false), oStdDone(false) {

  // Recomputing matrix to be made of columns instead of lines
  matrix = new double* [ncols];
  for(uint c = 0; c < ncols; c++)
    setMColumn(c, new double [nrows]);
  
  // Copy the elements
  for(uint r = 0; r < nrows; r++) {
    for(uint c = 0; c < ncols; c++) {
      double val = m[r][c];

      if(c < outputs && val < 0.01) {
	MSZWarn("Output %u in row %u is less than 0.01. Resizing to 0.01.", c, r);
	val = 0.01;
      }
      
      setMValue(r, c, val);
    }
  }
  
  printRawMatrix();

  // Delete old matrix
  for(uint r = 0; r < nrows; r++)
    delete[] m[r];
  delete[] m;
}
  
MSZDataSet::MSZDataSet(const MSZDataSet& ds) 
  : nrows(ds.nrows), rfeatures(ds.rfeatures), ncols(ds.ncols),
    outputs(ds.outputs), stdDone(ds.stdDone), oStdDone(ds.oStdDone) 
{

  // Now we just need to copy the matrix.
  matrix = new double* [ncols];
  for(uint c = 0; c < ncols; c++)
    setMColumn(c, new double [nrows]);

  for(uint r = 0; r < nrows; r++)
    for(uint c = 0; c < ncols; c++)
      setMValue(r, c, ds.getMValue(r, c));

}

MSZDataSet::~MSZDataSet() {

  // Please God, do not let this Seg Fault!

  // Clean up matrix by deleting each line.
  for(uint c = 0; c < ncols; c++) 
    delete[] getMColumn(c);
	 
  delete[] matrix;
  
}

void MSZDataSet::printRawMatrix() {

  cerr << "Printing all matrix [" << nrows << ", " << ncols << "]\n";
  for(uint r = 0; r < nrows; r++) {
    cerr << "[Row " << r << "] ";
    for(uint c = 0; c < ncols; c++) {
      cerr << getMValue(r, c) << " ";
    }
    cerr << "\n";
  }

}

void MSZDataSet::dumpPlotFiles(const vector<string> &labels, const string &prefix) const {

  if(labels.size() != ncols) {
    cerr << "Warning: Trying to dump plot files but labels vector is too small.\n";
    cerr << "Labels has size " << labels.size() << " but we have " << ncols << " columns.\n";
    return;
  }

  // Dump the files for plotting features against output
  for(uint f1 = 0; f1 < outputs; f1++) {
    for(uint f2 = (f1 < outputs ? outputs : f1+1); f2 < ncols; f2++) {
      ofstream file;
      file.open((prefix + "@" + labels[f1] + "@" + labels[f2] + ".dat").c_str());
      
      file << "# This file is generated by MatSATZilla\n"
	   << "# It should be used with gnuplot to plot\n"
	   << "# the feature " << labels[f2] << " against\n"
	   << "# the output " << labels[f1] << "\n"
	   << "#\n"
	// Outputting timestamp could be nice.
	//<< "# Timestamp: " << 
	   << "#\n"
	   << "# " << labels[f2] << "\t\t" << labels[f1] << "\n";
      
      // For each instance
      for(uint i = 0; i < nrows; i++) 
	file << getMValue(i, f2) << "\t\t" << getMValue(i, f1) << "\n";

      file.close();
    }
  }
}

void MSZDataSet::printSolverStats(uint timeout, const vector<string> &slabels) {

  if(slabels.size() != outputs) {
    cerr << "printSolverStats: You're passing in " << slabels.size() << " solver labels but there are " << outputs << " outputs in dataset.\n";
    return;
  }

  vector<uint> nbTimeouts(outputs, 0);
  vector<uint> nbOtherErrors(outputs, 0);

  for(uint s = 0; s < outputs; s++) {
    for(uint i = 0; i < nrows; i++) {
      if(getMValue(i, s) == timeout)
	nbTimeouts[s]++;
      else if(getMValue(i, s) == 2*timeout)
	nbOtherErrors[s]++;
    }
  }

  for(uint s = 0; s < outputs; s++) {
    cout << "Solver: " << slabels[s] << "\n"
	 << "\t\tTimeouts: " << nbTimeouts[s] << " (" << (((double)(nbTimeouts[s])) / nrows)*100.0 << ")\n"
	 << "\t\tOther Errors: " << nbOtherErrors[s] << " (" << (((double)(nbOtherErrors[s])) / nrows)*100.0 << ")\n"
	 << "\t\tUsable Instances: " << nrows - nbTimeouts[s] - nbOtherErrors[s] << " (" << (((double)(nrows - nbTimeouts[s] - nbOtherErrors[s])) / nrows)*100.0 << ")\n";
  }

}

void MSZDataSet::dumpPlotFiles(char **labels, uint len, char *prefix) const {

  vector<string> vec(len);

  for(uint i = 0; i < len; i++)
    vec[i] = string(labels[i]);

  dumpPlotFiles(vec, string(prefix));
}

double MSZDataSet::getOutputValue(uint row, uint col) const {
  assert(row < nrows);
  assert(col < outputs);

  return getMValue(row, col);
}

double MSZDataSet::getFeatureValue(uint row, uint col) const {
  assert(row < nrows);
  assert(col < ncols - outputs);

  return getMValue(row, col+outputs);
}

void MSZDataSet::standardize() {
  
  cout << "Standardizing features forall k . x_k = `q(x_k - x')/sdv_i(x_i)...\n";

  if(!stdDone) {
    for(uint c = outputs; c < ncols; c++) {

      // Compute column mean and compute column variance.
      double mean = 0.0;
      for(uint r = 0; r < nrows; r++) 
	mean += getMValue(r, c);
      mean /= nrows;

      cout << "[Feature " << c-outputs << "] Centering = " << mean << "; ";

      // Compute column standard deviation. 
      double sdv = 0.0;
      for(uint r = 0; r < nrows; r++) 
	sdv += gsl_pow_2(getMValue(r, c) - mean);
      sdv /= nrows;
      sdv = sqrt(sdv);

      cout << "Scaling = " << sdv << "\n";

      for(uint r = 0; r < nrows; r++) 
	setMValue(r, c, (getMValue(r, c) - mean) / sdv);
	
    }

  }
  stdDone = true;

  cout << "DONE\n";

}

void MSZDataSet::removeFeatures(const vector<uint> &keepVec) {
  // We need to remove the feature indexes in vec from the current data.
  
  cout << "Keeping features in dataset: ";

  // Create the indices to keep
  // by: 
  // - incrementing all indices by output
  // - sorting
  // - adding output indices to the beginning of vector
  vector<uint> vec(keepVec);
  for(vector<uint>::iterator it = vec.begin(); 
      it != vec.end();
      it++)
    *it += outputs;
  sort(vec.begin(), vec.end());        // sorts 
  vec.insert(vec.begin(), outputs, 0); // adds positions
  for(uint o = 0; o < outputs; o++)   
    vec[o] += o;                       // sets positions

  if(vec.size() == ncols) { 
    cout << "ALL\n";
    return;
  } else {
    copy(vec.begin(), vec.end(), std::ostream_iterator<uint>(cout, " "));
    cout << std::endl;
  }

  // Count the number of raw features about to be removed
  uint rawToRemove = 0;
  for(vector<uint>::const_iterator it = vec.begin(); 
      it != vec.end();
      it++)
    if(*it >= outputs && *it < outputs + rfeatures) 
      rawToRemove++;

  rfeatures -= rawToRemove;
  const uint oldNCols = ncols;
  ncols = vec.size();
  
  // Now, we just need to delete the columns referenced in the vector
  // and resize the main column array (delete + new, no realloc!).
  double **newMatrix = new double* [ncols];
  // Note that the vector indices denote the destination column
  // in the new matrix and the vector contents the origin column on the
  // old matrix. This means that we need to copy the column v[i] of old matrix
  // to column i of the new matrix.
  for(uint c = 0; c < ncols; c++) {
    newMatrix[c] = getMColumn(vec[c]);
    setMColumn(vec[c], 0); // Those which are not 0 are the columns 
                        // that should be deleted afterwards
  }
  for(uint c = 0; c < oldNCols; c++)
    if(getMColumn(c) != 0) delete[] getMColumn(c);
  
  delete[] matrix;
  matrix = newMatrix;
}

void MSZDataSet::standardizeOutputs() {

  cout << "Standardizing outputs... ";

  if(!stdDone) {
    for(uint c = 0; c < outputs; c++) {
      for(uint r = 0; r < nrows; r++) {
	setMValue(r, c, log(getMValue(r, c)));
      }
    }
  }

  oStdDone = true;

  cout <<  "DONE\n";

}

void MSZDataSet::expand(uint n) { 
  vector<uint> pvec(ncols - outputs); 
  for(uint i = 0; i < pvec.size(); i++)
    pvec[i] = i;

  expandOnPartition(n, pvec);
}

void MSZDataSet::expand(uint n, const vector<vector<uint> > &pvec) {
  for(uint i = 0; i < pvec.size(); i++)
    expandOnPartition(n, pvec[i]);
}

void MSZDataSet::expandOnPartition(uint k, const vector<uint> &pvec) {
  
  // expansion is quadratic at the minimum and 
  // and be bigger than partition size.
  assert(k >= 2 && k <= pvec.size());

  // Standardize features
  standardize();

  // Output information
  cout << "Expanding feature set by order " << k << " on partition:\n";
  copy(pvec.begin(), pvec.end(), std::ostream_iterator<uint>(cout, " "));
  cout << "\n";

  // Reallocate the data.
  // If we have N features, then, to expand to a order-K polynomial
  // we are adding 
  // n + (n !) / (k! (n-k!))
  uint num = 1;
  for(uint i = 0; i < k; i++) num *= rfeatures - i; // for big k hell breaks loose
  uint den = 1;
  for(uint i = k; i > 0; i--) den *= i; 
  uint nNewF = rfeatures;
  nNewF += num / den;
  ncols += nNewF; // Update number of columns

  cout << "Expansion increases feature set by " << nNewF << " columns " << " summing a total of " << ncols << " columns.\n";
  
  // Reallocating main vector and copying all the others to their initial places.
  double **newMatrix = new double* [ncols];
  for(uint c = 0; c < ncols - nNewF; c++)
    newMatrix[c] = getMColumn(c);
  delete[] matrix;
  matrix = newMatrix;

  for(uint nc = ncols - nNewF; nc < ncols; nc++)
    setMColumn(nc, new double [nrows]);

  // Compute the cross products
  // To do this we compute all the indices combinations and use them
  // to compute the cross product on columns defined in pvec.
  uint currColumn = rfeatures + outputs;
  const uint n = pvec.size();
  gsl_combination * c;
  c = gsl_combination_calloc (n, k);
  uint *ind = new uint [k];
  
  // Compute cross product for initial configuration
  // Now using the very nice combination structure from GSL.
  // Up to rev. 121, we used custom combination generator.
  do {
    for(uint i = 0; i < k; i++)
      ind[i] = gsl_combination_get(c, i);

    // Compute cross product in current configuration
    for(uint r = 0; r < nrows; r++) {
      const double cprod = computeCrossProduct(r, ind, k, pvec);
      setMValue(r, currColumn, cprod);
    }
    currColumn++;
  } while(gsl_combination_next (c) == GSL_SUCCESS);
  gsl_combination_free (c);
  delete[] ind;

  // Compute Powers
  for(uint i = 0; i < pvec.size(); i++) {
    for(uint r = 0; r < nrows; r++) {
      // Compute powers for pvec[i] feature
      setMValue(r, currColumn, gsl_pow_int(getMValue(r, pvec[i]), k));
    }
  }

}

double MSZDataSet::computeCrossProduct(uint r, uint *ind, uint k, const vector<uint> &vec) {
  double cp = 1.0; // Cross-product
  for(uint i = 0; i < k; i++)
    cp *= getMValue(r, vec[ind[i]]);
  return cp;
}

void MSZDataSet::removeTimeouts(uint timeout, uint out) {
  assert(out < outputs);

  if(oStdDone) {
    cerr << "Output standardization already performed. Cannot remove timeouts.\n";
    return;
  }

  // Count and keep rows without timeouts
  vector<uint> keepRows;
  for(uint r = 0; r < nrows; r++) {
    if(getMValue(r, out) != timeout) 
      keepRows.push_back(r);
  }

  if(keepRows.size() == nrows) {
    cout << "There are no rows to remove.\n";
    return;
  }

  cout << "Removing " << nrows - keepRows.size() 
       << " (" <<  (double)(nrows - keepRows.size()) / nrows << "%) of dataset due to timeout.\n";

  // Allocating new matrix
  double **newMatrix = new double* [ncols];
  for(uint c = 0; c < ncols; c++)
    newMatrix[c] = new double [keepRows.size()];

  nrows = keepRows.size();

  for(uint c = 0; c < ncols; c++) {
    uint nr = 0;
    for(vector<uint>::const_iterator rptr = keepRows.begin();
	rptr != keepRows.end();
	rptr++) {
      assert(*rptr >= nr);

      newMatrix[c][nr++] = getMValue(*rptr, c);
    }
  }

  // delete old matrix
  for(uint c = 0; c < ncols; c++)
    delete [] matrix[c];
  delete [] matrix;

  matrix = newMatrix;

}

/////////////////////////////////////////
/////////////////////////////////////////
//
// API Entrace Function for Data Set creation
//
/////////////////////////////////////////
/////////////////////////////////////////

MSZDataSet *createDataSet(double** matrix, uint nrows, uint ncols, uint outputs) {
  assert(nrows > 0);
  assert(ncols > 0);
  assert(matrix != 0);
  assert(outputs > 0);
  assert(nrows >= ncols - outputs);
  
#ifndef NDEBUG
  for(uint r = 0; r < nrows; r++)
    assert(matrix[r] != 0);
#endif // NDEBUG

  // The call!
  MSZDataSet *ds = new MSZDataSet(matrix, nrows, ncols, outputs);
  if(!ds) {
    cerr << "Error: Allocation of Dataset\n";
    exit(EXIT_FAILURE);
  }
  
  return ds;
}
