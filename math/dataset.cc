#include <iostream>
#include <fstream>

#include <iostream>
#include <iterator>
#include <cstdlib>
#include <cassert>
#include <cmath>

#include <gsl/gsl_math.h>
#include <gsl/gsl_combination.h>

#include "dataset.hh"

using std::cout;
using std::cerr;
using std::ofstream;

MSZDataSet::MSZDataSet(double **matrix, size_t nrows, size_t ncols, size_t outputs) 
  : matrix(matrix), nrows(nrows), rfeatures(ncols - outputs), ncols(ncols), outputs(outputs) {}
  
MSZDataSet::~MSZDataSet() {

  // Please God, do not let this Seg Fault!

  // Clean up matrix by deleting each line.
  for(size_t row = 0; row < nrows; row++) 
    delete[] matrix[row];
	 
  delete[] matrix;
  
}

void MSZDataSet::dumpPlotFiles(const vector<string> &labels, const string &prefix) const {

  if(labels.size() != ncols) {
    cerr << "Warning: Trying to dump plot files but labels vector is too small.\n";
    cerr << "Labels has size " << labels.size() << " but we have " << ncols << " columns.\n";
    return;
  }

  // Dump the files for plotting features against output
  for(size_t out = 0; out < outputs; out++) {
    for(size_t feature = outputs; feature < ncols; feature++) {
      ofstream file;
      file.open((prefix + "_" + labels[out] + "_" + labels[feature] + ".dat").c_str());
      
      file << "# This file is generated by MatSATZilla\n"
	   << "# It should be used with gnuplot to plot\n"
	   << "# the feature " << labels[feature] << " against\n"
	   << "# the output " << labels[out] << "\n"
	   << "#\n"
	// Outputting timestamp could be nice.
	//<< "# Timestamp: " << 
	   << "#\n"
	   << "# " << labels[feature] << "\t\t" << labels[out] << "\n";
      
      // For each instance
      for(size_t i = 0; i < nrows; i++) 
	file << matrix[i][feature] << "\t\t" << matrix[i][out] << "\n";

      file.close();
    }
  }

  // Dump the files for plotting features against themselves
  for(size_t f1 = outputs; f1 < ncols-1; f1++) {
    for(size_t f2 = f1+1; f2 < ncols; f2++) {
      assert(f1 != f2); // Shouldn't be plotting same features
      assert(labels[f1] != labels[f2]); // There shouldn't be two labels with the same name
      ofstream file;
      file.open((prefix + "_" + labels[f1] + "_" + labels[f2] + ".dat").c_str());
      
      file << "# This file is generated by MatSATZilla\n"
	   << "# It should be used with gnuplot to plot\n"
	   << "# the feature " << labels[f2] << " against\n"
	   << "# the feature " << labels[f1] << "\n"
	   << "#\n"
	// Outputting timestamp could be nice.
	//<< "# Timestamp: " << 
	   << "#\n"
	   << "# " << labels[f2] << "\t\t" << labels[f1] << "\n";
      
      // For each instance
      for(size_t i = 0; i < nrows; i++) 
	file << matrix[i][f2] << "\t\t" << matrix[i][f1] << "\n";

      file.close();
    }
  }
}

void MSZDataSet::printSolverStats(size_t timeout, const vector<string> &slabels) {

  if(slabels.size() != outputs) {
    cerr << "printSolverStats: You're passing in " << slabels.size() << " solver labels but there are " << outputs << " outputs in dataset.\n";
    return;
  }

  vector<size_t> nbTimeouts(outputs, 0);
  vector<size_t> nbOtherErrors(outputs, 0);

  for(size_t s = 0; s < outputs; s++) {
    for(size_t i = 0; i < nrows; i++) {
      if(matrix[i][s] == timeout)
	nbTimeouts[s]++;
      else if(matrix[i][s] == 2*timeout)
	nbOtherErrors[s]++;
    }
  }

  for(size_t s = 0; s < outputs; s++) {
    cout << "Solver: " << slabels[s] << "\n"
	 << "\t\tTimeouts: " << nbTimeouts[s] << " (" << (((double)(nbTimeouts[s])) / nrows)*100.0 << ")\n"
	 << "\t\tOther Errors: " << nbOtherErrors[s] << " (" << (((double)(nbOtherErrors[s])) / nrows)*100.0 << ")\n"
	 << "\t\tUsable Instances: " << nrows - nbTimeouts[s] - nbOtherErrors[s] << " (" << (((double)(nrows - nbTimeouts[s] - nbOtherErrors[s])) / nrows)*100.0 << ")\n";
  }

}

void MSZDataSet::dumpPlotFiles(char **labels, size_t len, char *prefix) const {

  vector<string> vec(len);

  for(size_t i = 0; i < len; i++)
    vec[i] = string(labels[i]);

  dumpPlotFiles(vec, string(prefix));
}

double MSZDataSet::getOutputValue(size_t row, size_t col) const {
  assert(row < nrows);
  assert(col < outputs);

  return matrix[row][col];
}

double MSZDataSet::getFeatureValue(size_t row, size_t col) const {
  assert(row < nrows);
  assert(col < ncols - outputs);

  return matrix[row][col+outputs];
}

void MSZDataSet::standardize() {
  
  cout << "Standardizing features ...";

  static bool stdDone = false;

  if(!stdDone) {
    for(size_t c = outputs; c < ncols; c++) {

      // Compute column mean and compute column variance.
      double mean = 0.0;
      for(size_t r = 0; r < nrows; r++) 
	mean += matrix[r][c];
      mean /= nrows;

      // Compute column standard deviation. 
      double sdv = 0.0;
      for(size_t r = 0; r < nrows; r++) 
	sdv += gsl_pow_2(matrix[r][c] - mean);
      sdv /= nrows;

      for(size_t r = 0; r < nrows; r++) 
	matrix[r][c] = (matrix[r][c] - mean) / sdv;
	
    }

  }
  stdDone = true;

  cout << "DONE\n";

}

void MSZDataSet::removeFeatures(const vector<size_t> &keepVec) {
  // We need to remove the feature indexes in vec from the current data.
  
  cout << "Pruning features from dataset: ";

  // Create the indices to remove
  vector<size_t> vec;
  for(size_t i = outputs; i < ncols; i++)
    if(find(keepVec.begin(), keepVec.end(), i-outputs) == keepVec.end())
      vec.push_back(i);

  if(vec.size() == 0) { 
    cout << "NONE\n";
    return;
  } else {
    copy(vec.begin(), vec.end(), std::ostream_iterator<size_t>(cout, " "));
    cout << std::endl;
  }

  // Let's setup all the variables
  size_t currRawFeatures = rfeatures;
  size_t currCols = ncols;
  for(size_t i = 0; i < vec.size(); i++) {
    ncols--;
    if(vec[i] < currRawFeatures)
      rfeatures--; 
  }
  
  // Now we need to recreate matrix.
  // KILL ME
  double **newMatrix = (double**)malloc(nrows * sizeof(*newMatrix));
  for(size_t r = 0; r < nrows; r++)
    newMatrix[r] = (double*)malloc(ncols * sizeof(**newMatrix));
  
  // Copy every column to the new matrix except those listed in vec.
  size_t destc = 0;
  for(size_t origc = 0; origc < currCols; origc++) {
    if(find(vec.begin(), vec.end(), origc) != vec.end())
      continue;
    assert(destc < ncols);
    for(size_t r = 0; r < nrows; r++)
      newMatrix[r][destc] = matrix[r][origc];
    destc++;
  }
  
  // free previous matrix
  for(size_t r = 0; r < nrows; r++)
    free(matrix[r]);
  free(matrix);

  matrix = newMatrix;
}

void MSZDataSet::standardizeOutputs() {

  cout << "Standardizing outputs... ";

  static bool stdDone = false;

  if(!stdDone) {
    for(size_t c = 0; c < outputs; c++)
      for(size_t r = 0; r < nrows; r++)
	matrix[r][c] = log(matrix[r][c]);
  }

  stdDone = true;

  cout <<  "DONE\n";

}

void MSZDataSet::expand(size_t n) { 
  vector<size_t> pvec(ncols - outputs); 
  for(size_t i = 0; i < pvec.size(); i++)
    pvec[i] = i;

  expandOnPartition(n, pvec);
}

void MSZDataSet::expand(size_t n, const vector<vector<size_t> > &pvec) {
  for(size_t i = 0; i < pvec.size(); i++)
    expandOnPartition(n, pvec[i]);
}

void MSZDataSet::expandOnPartition(size_t k, const vector<size_t> &pvec) {
  
  // expansion is quadratic at the minimum and 
  // and be bigger than partition size.
  assert(k > 2 && k <= pvec.size());

  // Standardize features
  standardize();

  // Reallocate the data.
  // If we have N features, then, to expand to a order-K polynomial
  // we are adding 
  // n + (n !) / (k! (n-k!))
  size_t num = 1;
  for(size_t i = 0; i < k; i++) num *= rfeatures - i; // for big k hell breaks loose
  size_t den = 1;
  for(size_t i = k; i > 0; i--) den *= i; 
  size_t nNewF = rfeatures;
  nNewF += num / den;
  ncols += nNewF; // Update number of columns

  // Now, we need to realloc all the structure
  for(size_t r = 0; r < nrows; r++) {
    matrix[r] = (double*)realloc(matrix[r], sizeof(**matrix) * (nNewF + ncols));
    if(matrix[r] == 0) {
      cerr << "Bad news... while trying to allocate memory...\n"; 
      exit(EXIT_FAILURE);
    }
  }
  
  // Compute the cross products
  // To do this we compute all the indices combinations and use them
  // to compute the cross product on columns defined in pvec.
  size_t currColumn = rfeatures + outputs;
  const size_t n = pvec.size();
  gsl_combination * c;
  c = gsl_combination_calloc (n, k);
  size_t *ind = new size_t [k];
  
  // Compute cross product for initial configuration
  // Now using the very nice combination structure from GSL.
  // Up to rev. 121, we used custom combination generator.
  do {
    for(size_t i = 0; i < k; i++)
      ind[i] = gsl_combination_get(c, i);

    // Compute cross product in current configuration
    for(size_t r = 0; r < nrows; r++) {
      matrix[r][currColumn] = computeCrossProduct(r, ind, k, pvec);
    }
    currColumn++;
  } while(gsl_combination_next (c) == GSL_SUCCESS);
  gsl_combination_free (c);
  delete ind;

  // Compute Powers
  for(size_t i = 0; i < pvec.size(); i++) {
    for(size_t r = 0; r < nrows; r++) {
      // Compute powers for pvec[i] feature
      matrix[r][currColumn] = gsl_pow_int(matrix[r][pvec[i]], k);
    }
  }

}

double MSZDataSet::computeCrossProduct(size_t r, size_t *ind, size_t k, const vector<size_t> &vec) {
  double cp = 1.0; // Cross-product
  for(size_t i = 0; i < k; i++)
   cp *= matrix[r][vec[ind[i]]];
  return cp;
}

/////////////////////////////////////////
/////////////////////////////////////////
//
// API Entrace Function for Data Set creation
//
/////////////////////////////////////////
/////////////////////////////////////////

MSZDataSet *createDataSet(double** matrix, size_t nrows, size_t ncols, size_t outputs) {
  assert(nrows > 0);
  assert(ncols > 0);
  assert(matrix != 0);
  assert(outputs > 0);
  assert(nrows >= ncols - outputs);
  
#ifndef NDEBUG
  for(size_t r = 0; r < nrows; r++)
    assert(matrix[r] != 0);
#endif // NDEBUG

  // The call!
  MSZDataSet *ds = new MSZDataSet(matrix, nrows, ncols, outputs);
  if(!ds) {
    cerr << "Error: Allocation of Dataset\n";
    exit(EXIT_FAILURE);
  }
  
  return ds;
}
