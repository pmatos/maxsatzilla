#include <iostream>
#include <fstream>

#include <iostream>
#include <iterator>
#include <cstdlib>
#include <cassert>
#include <cmath>
#include <utility>
#include <map>
#include <algorithm>

#include <gsl/gsl_math.h>
#include <gsl/gsl_combination.h>

#include "dataset.hh"
#include "logmgm.hh"

using std::cout;
using std::cerr;
using std::ofstream;
using std::pair;
using std::make_pair;
using std::map;

MSZDataSet::MSZDataSet(const double* const* m, uint nrows, uint ncols, const string* mlabels, const double* ov, const string& olabel)
  : nrows(nrows), ncols(ncols), stdDone(false), oStdDone(false) {

  // Recomputing matrix to be made of columns instead of lines
  matrix = new double* [ncols];
  for(uint c = 0; c < ncols; c++) {
    // Copy label also
    FeatureLabel fl(mlabels[c]);
    labels.push_back(fl);
    // Create column
    setMColumn(c, new double [nrows]);
  }
  
  // Copy the elements
  for(uint r = 0; r < nrows; r++) 
    for(uint c = 0; c < ncols; c++) 
      setMValue(r, c, m[r][c]);  

  // Create the output vector
  ovec = new double [nrows];

  // Copy label
  vecLabel = olabel;
  for(uint i = 0; i < nrows; i++) {
    // Handle value
    double val = ov[i];
 
    if(val < 0.01) {
      MSZWarn("Output %u of %s is less than 0.01. Resizing to 0.01.", i, olabel.c_str());
      val = 0.01;
    }   
    setVValue(i, val);
  }
}
  
MSZDataSet::MSZDataSet(const MSZDataSet& ds) 
  : nrows(ds.nrows), ncols(ds.ncols), stdDone(ds.stdDone), oStdDone(ds.oStdDone) {

  // Now we just need to copy the matrix.
  matrix = new double* [ncols];
  for(uint c = 0; c < ncols; c++)
    setMColumn(c, new double [nrows]);

  for(uint r = 0; r < nrows; r++)
    for(uint c = 0; c < ncols; c++)
      setMValue(r, c, ds.getMValue(r, c));

  // Copy the output vector
  ovec = new double [ncols];
  for(uint i = 0; i < ncols; i++)
    setVValue(i, ds.getVValue(i));

  // Copy the labels
  labels = ds.labels;
  vecLabel = ds.vecLabel;
  
}

MSZDataSet::~MSZDataSet() {
  // Please God, do not let this Seg Fault!

  // Clean up matrix by deleting each line.
  for(uint c = 0; c < ncols; c++) 
    delete[] getMColumn(c);
	 
  delete[] matrix;
  delete[] ovec;
}

void MSZDataSet::printRawMatrix() {

  cerr << "Printing all matrix [" << nrows << ", " << ncols << "]\n";
  for(uint r = 0; r < nrows; r++) {
    cerr << "[Row " << r << "] ";
    for(uint c = 0; c < ncols; c++) {
      cerr << getMValue(r, c) << " ";
    }
    cerr << "\n";
  }

}

void MSZDataSet::dumpPlotFiles(const string &prefix) const {
  // Dump the files for plotting features against output
  for(uint f = 0; f < ncols; f++) {
    ofstream file;
    file.open((prefix + "@" + vecLabel + "@" + 
	       labels[f].toContString() + ".dat").c_str());
    
    file << "# This file is generated by MatSATZilla\n"
	 << "# It should be used with gnuplot to plot\n"
	 << "# the feature " << labels[f] << " against\n"
	 << "# the output " << vecLabel << "\n"
	 << "#\n"
      // Outputting timestamp could be nice.
      //<< "# Timestamp: " << 
	 << "#\n"
	 << "# " << labels[f] << "\t\t" << vecLabel << "\n";
    
    // For each instance
    for(uint i = 0; i < nrows; i++) 
      file << getMValue(i, f) << "\t\t" << getVValue(i) << "\n";
    
    file.close();
  }
}

void MSZDataSet::printSolverStats(uint timeout) {

  uint nbTimeouts = 0;

  for(uint i = 0; i < nrows; i++) {
    if(getVValue(i) == timeout)
      nbTimeouts++;
  }

  cout << "Solver: " << vecLabel << "\n"
       << "\t\tTimeouts: " << nbTimeouts << " (" << (((double)(nbTimeouts)) / nrows)*100.0 << ")\n"
       << "\t\tUsable Instances: " << nrows - nbTimeouts << " (" << (((double)(nrows - nbTimeouts)) / nrows)*100.0 << ")\n";

}

double MSZDataSet::getOutputValue(uint row) const {
  assert(row < nrows);
  return getVValue(row);
}

double MSZDataSet::getFeatureValue(uint row, uint col) const {
  assert(row < nrows);
  assert(col < ncols);
  return getMValue(row, col);
}

vector<Triple<FeatureLabel, double, double> > MSZDataSet::standardize() {

  vector<Triple<FeatureLabel, double, double> > mfactors;

  for(uint c = 0; c < ncols; c++) {
    const pair<double, double> f = computeStdFactors(c);
    mfactors.push_back(make_triple(getColLabel(c), f.first, f.second));
  }

  standardize(mfactors);

  return mfactors;
}

void MSZDataSet::standardize(const vector<Triple<FeatureLabel, double, double> > &factors) {
  
  cout << "Standardizing features forall k . x_k = `q(x_k - x')/sdv_i(x_i)...\n";

  if(!stdDone) {
    for(uint c = 0; c < ncols; c++) {
      const FeatureLabel& fl = getColLabel(c);
      // Let's find the vector position with this label
      uint i;
      for(i = 0; i < factors.size(); ++i)
	if(factors[i].first == fl) break;
      // i contains the vector index of the correct label
      const double mean = factors[i].second;
      const double sdv = factors[i].third;

      cout << "[Feature " << labels[c]
	   << "] Centering = " << mean << "; "
	   << "Scaling = " << sdv << "\n";

      for(uint r = 0; r < nrows; r++) {
	const double val = (getMValue(r, c) - mean) / sdv;
	if(isnan(val)) {
	  cerr << "MSZDataSet::standardize: NaN Error!\n"
	       << "Output Label " << getOutputLabel() << "\n"
	       << "Row, Col: " << r << ", " << c << "\n"
	       << "Feature: " << labels[c] << "\n"
	       << "Value: " << getMValue(r,c) << "\n"
	       << "Centering: " << mean << "\n"
	       << "Scaling: " << sdv << "\n";
	  exit(EXIT_FAILURE);
	}
	setMValue(r, c, val);
      }
	
    }
    
  }
  stdDone = true;

  cout << "DONE\n";

}

/** Computes features standardization factors for a column
 *  @returns a pair with the centering factor (mean) and the
 *  @returns scaling factor (std deviation).
 */
pair<double, double> MSZDataSet::computeStdFactors(uint c) {
  
  // Compute column mean and compute column standard deviation.
  double mean = 0.0;
  for(uint r = 0; r < nrows; r++) 
    mean += getMValue(r, c);
  mean /= nrows;
  
  double sdv = 0.0;
  for(uint r = 0; r < nrows; r++) 
    sdv += gsl_pow_2(getMValue(r, c) - mean);
  sdv /= nrows;
  sdv = sqrt(sdv); 

  return make_pair(mean, sdv);
}

void MSZDataSet::removeFeatures(const vector<uint> &keepVec) {
  // We need to remove the feature indexes in vec from the current data.
  
  cout << "[" << getOutputLabel() << "] Keeping features in dataset: ";

  // Create the indices to keep
  // by: 
  // - incrementing all indices by output
  // - sorting
  // - adding output indices to the beginning of vector
  vector<uint> vec(keepVec);
  
  if(vec.size() == ncols) { 
    cout << "ALL\n";
    return;
  } else {
    for(vector<uint>::const_iterator it = keepVec.begin();
	it != keepVec.end();
	it++)
      cout << getColLabel(*it) << "(" << *it << ") ";
    cout << std::endl;
  }

  sort(vec.begin(), vec.end());        // sorts 

  const uint oldNCols = ncols;
  ncols = vec.size();
  
  // Now, we just need to delete the columns referenced in the vector
  // and resize the main column array (delete + new, no realloc!).
  double **newMatrix = new double* [ncols];
  
  vector<FeatureLabel> newLabels;
  // Note that the vector indices denote the destination column
  // in the new matrix and the vector contents the origin column on the
  // old matrix. This means that we need to copy the column v[i] of old matrix
  // to column i of the new matrix.
  for(uint c = 0; c < ncols; c++) {
    newMatrix[c] = getMColumn(vec[c]);
    newLabels.push_back(labels[vec[c]]);
    setMColumn(vec[c], 0); // Those which are not 0 are the columns 
                           // that should be deleted afterwards
  }
  for(uint c = 0; c < oldNCols; c++)
    if(getMColumn(c) != 0) delete[] getMColumn(c);
  
  delete[] matrix;
  matrix = newMatrix;
  labels = newLabels;
}

void MSZDataSet::standardizeOutput() {

  cout << "Standardizing outputs... ";

  if(!stdDone) 
    for(uint i = 0; i < nrows; i++) 
      setVValue(i, log(getVValue(i)));

  oStdDone = true;

  cout <<  "DONE\n";

}

void MSZDataSet::expand(uint n) { 
  vector<uint> pvec(ncols); 
  for(uint i = 0; i < pvec.size(); i++)
    pvec[i] = i;

  expandOnPartition(n, pvec);
}

void MSZDataSet::expand(uint n, const vector<vector<uint> > &pvec) {
  for(uint i = 0; i < pvec.size(); i++)
    expandOnPartition(n, pvec[i]);
}

void MSZDataSet::expandOnPartition(uint k, const vector<uint> &pvec) {
  
  // expansion is quadratic at the minimum and 
  // and be bigger than partition size.
  assert(k >= 2 && k <= pvec.size());

  // Output information
  cout << "Expanding feature set by order " << k << " on partition:\n";
  copy(pvec.begin(), pvec.end(), std::ostream_iterator<uint>(cout, " "));
  cout << "\n";
  
  const uint psize = pvec.size();

  // Reallocate the data.
  // If we have N features, then, to expand to a order-K polynomial
  // we are adding 
  // n + (n !) / (k! (n-k!))
  uint num = 1;
  for(uint i = 0; i < k; i++) num *= psize - i; // for big k hell breaks loose
  uint den = 1;
  for(uint i = k; i > 0; i--) den *= i; 
  uint nNewF = psize;
  nNewF += num / den;
  const uint oldncols = ncols;
  ncols += nNewF; // Update number of columns

  cout << "Expansion increases feature set by " << nNewF << " columns, summing a total of " << ncols << " columns.\n";
  
  // Reallocating main vector and copying all the others to their initial places.
  double **newMatrix = new double* [ncols];
  for(uint c = 0; c < oldncols; ++c)
    newMatrix[c] = getMColumn(c);
  delete[] matrix;
  matrix = newMatrix;

  for(uint nc = oldncols; nc < ncols; nc++)
    setMColumn(nc, new double [nrows]);

  // Compute the cross products
  // To do this we compute all the indices combinations and use them
  // to compute the cross product on columns defined in pvec.
  uint currColumn = oldncols;
  gsl_combination * c;
  c = gsl_combination_calloc (psize, k);
  uint *ind = new uint [k]; // Contains the combinations
  
  // Compute cross product for initial configuration
  // Now using the very nice combination structure from GSL.
  // Up to rev. 121, we used custom combination generator.
  do {
    for(uint i = 0; i < k; i++)
      ind[i] = gsl_combination_get(c, i);

    // Compute cross product in current configuration
    for(uint r = 0; r < nrows; r++) {
      const double cprod = computeCrossProduct(r, ind, k, pvec);
      setMValue(r, currColumn, cprod);
    }
    
    // Update labels
    FeatureLabel newLabel;
    for(uint i = 0; i < k; i++) 
      newLabel.append(labels[ind[i]]);
    labels.push_back(newLabel);

    currColumn++;
  } while(gsl_combination_next (c) == GSL_SUCCESS);
  gsl_combination_free (c);
  delete[] ind;

  assert(currColumn == ncols - pvec.size());

  // Compute Powers
  for(uint i = 0; i < pvec.size(); i++, currColumn++) {
    for(uint r = 0; r < nrows; r++) {
      // Compute powers for pvec[i] feature
      setMValue(r, currColumn, gsl_pow_int(getMValue(r, pvec[i]), k));
    }
    // Set label
    FeatureLabel newLabel;
    for(uint p = 0; p < k; p++)
      newLabel.append(labels[pvec[i]]);
    labels.push_back(newLabel);
  }

  cout << "Dataset after expansion has following labels:\n";
  for(uint i = 0; i < ncols; i++) 
    cout << i << ": " << getColLabel(i) << "\n";

}

double MSZDataSet::computeCrossProduct(uint r, uint *ind, uint k, const vector<uint> &vec) {
  double cp = 1.0; // Cross-product
  for(uint i = 0; i < k; i++)
    cp *= getMValue(r, vec[ind[i]]);
  return cp;
}

void MSZDataSet::removeTimeouts(uint timeout) {

  if(oStdDone) {
    cout << "Output standardization already performed. Cannot remove timeouts.\n";
    return;
  }

  // Count and keep rows without timeouts
  vector<uint> keepRows;
  for(uint r = 0; r < nrows; r++) {
    if(getVValue(r) != timeout) 
      keepRows.push_back(r);
  }

  if(keepRows.size() == nrows) {
    cout << "There are no rows to remove.\n";
    return;
  }

  cout << "Removing " << nrows - keepRows.size() 
       << " (" <<  (double)(nrows - keepRows.size()) / nrows << "%) of dataset due to timeout.\n";

  // Allocating new matrix
  double **newMatrix = new double* [ncols];
  for(uint c = 0; c < ncols; c++)
    newMatrix[c] = new double [keepRows.size()];

  nrows = keepRows.size();

  for(uint c = 0; c < ncols; c++) {
    uint nr = 0;
    for(vector<uint>::const_iterator rptr = keepRows.begin();
	rptr != keepRows.end();
	rptr++) {
      assert(*rptr >= nr);

      newMatrix[c][nr++] = getMValue(*rptr, c);
    }
  }

  // delete old matrix
  for(uint c = 0; c < ncols; c++)
    delete[] matrix[c];
  delete[] matrix;

  matrix = newMatrix;

}

void MSZDataSet::toCsv(const string& path) const {
  ofstream file(path.c_str());

  // Output first line with headers
  file << "\"Solver Runtime\"";
  for(uint c = 0; c < ncols; ++c) 
    file << ", " << "\"" << getColLabel(c) << "\"";
  file << "\n";

  // Output remaining lines
  for(uint r = 0; r < nrows; ++r) {
    file << getOutputValue(r);
    for(uint c = 0; c < ncols; ++c) {
      file << ", " << getFeatureValue(r, c);
    }
    file << "\n";
  }

  file.close();
}

/** 
 * Removes features containing an sdv == 0, i.e., all variables are the same.
 */ 
void MSZDataSet::removeHarmfulFeatures() {

  vector<uint> keepVec;

  for(uint c = 0; c < ncols; ++c) {
    pair<double, double> factors = computeStdFactors(c);
    
    if(factors.second == 0.0) 
      cout << "Marking harmful feature for removal: " << getColLabel(c) << "\n";
    else 
      keepVec.push_back(c);
  }

  removeFeatures(keepVec);

}

/////////////////////////////////////////
/////////////////////////////////////////
//
// API Entrace Function for Data Set creation
//
/////////////////////////////////////////
/////////////////////////////////////////

MSZDataSet *createDataSet(const double* const* matrix, 
			  uint nrows, 
			  uint ncols, 
			  const string* labels, 
			  const double* ovec, 
			  const string& ovecLabel) {
  assert(matrix != 0);
  
#ifndef NDEBUG
  for(uint r = 0; r < nrows; r++)
    assert(matrix[r] != 0);
#endif // NDEBUG

  // The call!
  MSZDataSet *ds = new MSZDataSet(matrix, nrows, ncols, labels, ovec, ovecLabel);
  
  return ds;
}


/** This function creates two datasets:
 * a training data set and a test data set, both of which without timeouts
 * and split according to the percentTest value.
 * @returns a pair with the training dataset in car and test dataset in cdr.
 */
pair<MSZDataSet *, MSZDataSet *> createDataSets(double** matrix, 
						uint nrows, 
						uint ncols, 
						const string* labels, 
						const double* ovec, 
						const string& ovecLabel,
						uint timeOut,
						uint percentTest) {

  // Create new matrix without timeouts
  uint nbTimeouts = 0;
  for(uint i = 0; i < nrows; i++)
    if(ovec[i] == timeOut) nbTimeouts++;

  const uint nbUsableRows = nrows - nbTimeouts;

  const uint testValue = (uint) floor((double)100.0 / (double)percentTest);
  uint nbTestRows = 0;

  for(uint row = 0; row < nrows; row++)
    if(ovec[row] != timeOut && row % testValue == 0) 
      nbTestRows++;

  const uint nbTrainingRows = nbUsableRows - nbTestRows;
  
  cout << "[" << ovecLabel << "]" << "After partitioning into training and test set:\n"
       << "\tTotal number of rows: " << nrows << "\n"
       << "\tTotal number of usable rows (without timeouts): " << nbUsableRows << "\n"
       << "\tTotal number of timeout/error rows: " << nrows - nbUsableRows << "\n"
       << "\tTotal number of training rows: " << nbTrainingRows << "\n"
       << "\tTotal number of test rows: " << nbTestRows << "\n";

  double **trainingMatrix = new double* [nbTrainingRows];
  double *trainingOVec = new double [nbTrainingRows];

  double **testMatrix = new double* [nbTestRows];
  double *testOVec = new double [nbTestRows]; 

  uint testRow = 0;
  uint trainingRow = 0;
  uint currentRow = 0;
  
  cout << "[" << ovecLabel << "]" << "Rows going to test set: ";

  while(currentRow != nrows) {
    assert(currentRow < nrows);
    if(ovec[currentRow] != timeOut) {
      // Will this be a training or a test row?
      if(currentRow % testValue == 0) { // test row
	assert(testRow < nbTestRows);
	cout << currentRow << " ";
	testMatrix[testRow] = matrix[currentRow];
	testOVec[testRow] = ovec[currentRow];
	testRow++;
      } else { // training row
	assert(trainingRow < nbTrainingRows);
	trainingMatrix[trainingRow] = matrix[currentRow];
	trainingOVec[trainingRow] = ovec[currentRow];
	trainingRow++;
      }
    }
    currentRow++;
  }

  cout << "\n";

  assert(trainingRow == nbTrainingRows);
  assert(testRow == nbTestRows);

  MSZDataSet *trainingDataSet = new MSZDataSet(trainingMatrix, nbTrainingRows, ncols, labels, trainingOVec, ovecLabel);
  MSZDataSet *testDataSet = new MSZDataSet(testMatrix, nbTestRows, ncols, labels, testOVec, ovecLabel);

  delete[] trainingMatrix;
  delete[] trainingOVec;
  delete[] testMatrix;
  delete[] testOVec;
  
  return std::make_pair(trainingDataSet, testDataSet);
}
